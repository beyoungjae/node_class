# Socket.IO를 이용한 인증 기반 실시간 통신 정리

웹 애플리케이션에서 실시간 통신을 최적화하고, 이를 안전하게 관리하기 위해서는 “왜, 어떻게, 무엇을 위해”라는 관점을 가지고 접근할 필요가 있습니다. 특히 Passport와 Express 세션을 활용한 인증 과정을 결합하면, “인증된 사용자만” 실시간 기능을 이용하도록 보안성을 높일 수 있습니다.

---

## **1. Socket.IO의 매력: 웹소켓을 이용한 실시간 통신**

### **1.1 왜?**

-  **실시간 응답**: HTTP는 요청이 있어야만 서버가 응답합니다. 채팅, 알림 등에서는 반대로 서버가 능동적으로 데이터를 전달해야 할 때가 많으므로, 실시간 기능이 필수입니다.
-  **양방향 통신**: 서버와 클라이언트가 서로 언제든 이벤트를 주고받을 수 있어야 하므로, 웹소켓 기반의 양방향 통신이 효율적입니다.

### **1.2 어떻게?**

1. **웹소켓(WebSocket) 프로토콜**

   -  Socket.IO는 웹소켓을 우선적으로 사용합니다.
   -  브라우저 호환성 이슈가 있으면 자동으로 롱 폴링(Long Polling) 등 대체 방식을 적용합니다.

2. **이벤트 기반 구조**
   -  **서버 측**:
      ```js
      io.on('connection', (socket) => {
         console.log('새 연결 발생')
         socket.on('eventName', (data) => {
            console.log('수신 데이터:', data)
         })
      })
      ```
   -  **클라이언트 측**:
      ```js
      const socket = io('http://localhost:3000')
      socket.emit('eventName', { sample: 'data' })
      socket.on('eventName', (res) => {
         console.log('서버 응답:', res)
      })
      ```

### **1.3 무엇을 위해?**

-  **채팅 애플리케이션**: 메시지 즉시 반영, typing 상태 표시 등
-  **라이브 알림 서비스**: 새로운 주문, 재고 변동 상황을 실시간 통보
-  **게임 로비**: 사용자가 많을 때에도 빠르게 점수, 상태를 공유
-  **실시간 협업**: 문서나 그래픽 편집 시 여러 사용자가 동시에 작업 가능

---

## **2. Express 세션 + Passport를 활용한 인증**

### **2.1 왜?**

-  익명 사용자가 웹소켓 연결을 통해 무분별하게 서버 자원을 사용하지 않도록 통제해야 합니다.
-  로그인한 사용자만 실시간 기능을 누릴 수 있게 제한해 스팸, 봇, 악성 사용 등을 방지할 수 있습니다.

### **2.2 어떻게?**

1. **Express 세션 설정**

   -  `express-session` 모듈을 사용해 쿠키 기반 세션을 구성합니다.
   -  민감한 설정(예: secret 키)은 `.env` 등 외부 파일에서 관리합니다.

2. **Passport.initialize() & Passport.session()**

   -  사용자가 로그인하면 Passport가 사용자 식별자(ID)를 세션에 저장합니다.
   -  이후 요청이 들어올 때 `deserializeUser`로 세션에서 해당 ID를 찾아 실제 사용자 정보를 복원합니다.

3. **Socket.IO에서 세션 재활용**

   -  Socket.IO에서 `io.use((socket, next) => sessionMiddleware(socket.request, {}, next))`를 통해 소켓 연결 시에도 세션 정보를 불러옵니다.
   -  `socket.request.session.passport.user`가 있으면 해당 소켓이 인증된 사용자로 간주할 수 있습니다.

4. **Passport 역직렬화(deserializeUser) 활용**
   -  인증이 확인되면 사용자의 상세 정보를 `socket.request.user`에 담아서 소켓 이벤트 처리 시 참조합니다.

### **2.3 무엇을 위해?**

-  **채팅 권한 통제**: 로그인된 사용자만 채팅 참여
-  **사용자별 맞춤 기능**: 권한 레벨에 따라 접근할 수 있는 리소스, 방 등이 달라질 수 있음
-  **스팸·트롤 방지**: 무작위 세션 생성이나 익명 악성 채팅을 차단

---

## **3. 이벤트 기반 프로그래밍: “emit”과 “on”으로 이루는 마법**

### **3.1 왜?**

-  특정 이벤트가 발생했을 때만 관련 로직을 수행하므로, 구조가 깔끔하고 유지보수하기 쉽습니다.
-  이벤트명만 정의해두면 원하는 기능을 자유롭게 확장할 수 있습니다.

### **3.2 어떻게?**

1. **Emit(전송)**

   -  클라이언트에서 특정 이벤트를 `socket.emit('chat message', { content: '안녕!' })` 형태로 보냅니다.
   -  서버가 이 이벤트를 받으면 필요한 처리를 해준 뒤, 다시 `io.emit(...)`이나 `socket.emit(...)`으로 응답을 보낼 수 있습니다.

2. **On(수신)**
   -  서버 측 “connection” 이벤트에서 각 클라이언트 연결을 감지하고, 제각각 필요한 커스텀 이벤트(`chat message` 등)를 `on`으로 처리합니다.
   -  메시지 저장, 특정 룸에만 전달, 기타 로직 등을 여기에 모두 담습니다.

### **3.3 무엇을 위해?**

-  **채팅 메시지 전달**: 메시지 내용, 전송 시간, 보낸 유저 정보를 실시간으로 주고받기
-  **알림 기능**: 새 글 작성, 댓글 작성, 좋아요 등 각종 액션에 대해 정의된 이벤트를 자동 전송
-  **서버 간 확장**: 필요하면 Redis, Kafka 등을 통해 여러 서버와도 이벤트를 주고받도록 구성

---

## **4. “disconnect” 이벤트: 정확한 종료 처리**

### **4.1 왜?**

-  사용자가 브라우저를 닫거나 네트워크 문제가 생겨도 서버에서는 “언제 접속이 끊겼는지” 알아야 합니다.
-  인원 수 표시, 퇴장 알림, 로그 기록 등의 처리를 위해 유용합니다.

### **4.2 어떻게?**

-  `socket.on('disconnect', () => { ... })` 구문을 사용해 연결 종료 시점을 인지합니다.
-  채팅방 인원 수 갱신, “○○님이 나갔습니다” 안내, DB 업데이트 등 후속 조치를 수행합니다.

### **4.3 무엇을 위해?**

-  **인원 수 표시**: 현재 방에 몇 명이 있는지 실시간 표시
-  **자원 정리**: 세션, 소켓 연결, 사용자 상태(온라인/오프라인) 정보 등을 동기화
-  **에러 추적**: 비정상 종료 횟수를 파악해 네트워크 문제나 클라이언트 오류를 분석

---

## **5. 신박한 응용 아이디어**

1. **타이핑 알림**
   -  사용자가 메시지 폼에 글을 쓰는 도중에 “typing” 이벤트를 서버에 보냄 → 클라이언트들에게 입력 중 상태 실시간 표시
2. **여러 방(Room) 관리**
   -  `io.to(roomId).emit('eventName', data)` 식으로 특정 방에만 이벤트를 전송하여 규모가 큰 채팅, 게임 파티 등 구현
3. **실시간 방송 & QnA**
   -  진행자가 실시간으로 질문을 던지고, 시청자들은 채팅창을 통해 바로 답변 → 진행자가 즉시 확인
4. **지도·위치 추적**
   -  배달, 택시 등에서 차량 이동 경로를 실시간으로 전달 → 지도에 반영
5. **게임 로비 & 멀티플레이**
   -  실시간 상태 동기화(유닛 이동, 전투 진행 등)로 다인 게임에 적용

---

## **6. 전체 흐름 한눈에 보기**

1. **서버**

   -  Express 세션과 Passport를 설정해 인증 환경을 마련합니다.
   -  Socket.IO 서버 생성 시 CORS 설정 등으로 클라이언트 주소나 허용 메서드를 지정합니다.
   -  세션 미들웨어를 `io.use()`로 연결하고, `passport.deserializeUser`를 통해 접속하려는 소켓이 인증된 사용자인지 확인합니다.

2. **클라이언트**

   -  Socket.IO 클라이언트 스크립트를 통해 `socket = io('서버주소')`로 연결 시도.
   -  인증 쿠키(세션ID)가 자동 전송되며, 서버는 이를 보고 사용자 인증 여부를 판별합니다.
   -  인증 통과 후에는 `emit`, `on` 이벤트를 활용해 채팅, 알림, 기타 기능을 실시간으로 주고받습니다.

3. **동작 시나리오**
   1. 웹페이지 접속 시 소켓 연결 시도
   2. 서버가 세션/Passport로 사용자 확인
   3. 인증 성공 시 connection 이벤트 정상 처리, 인증 실패 시 연결 거부
   4. 이벤트(`emit`, `on`)를 통해 메시지, 알림, 기타 기능 실시간 주고받기
   5. 사용자가 창을 닫거나 네트워크 문제로 소켓 연결이 끊기면 disconnect 이벤트에서 정리 작업 수행

---

## **7. 결론**

1. **실시간성**: Socket.IO는 순간적인 응답이 필요한 애플리케이션(채팅, 알림, 게임 등)에 적합합니다.
2. **안정성**: Express 세션과 Passport로 인증을 결합해, 허가된 사용자만 실시간 통신을 이용하도록 제어할 수 있습니다.
3. **유연성**: 이벤트 기반 구조 덕분에 다양한 기능을 자유롭게 확장하고, 이름만 지정하면 원하는 이벤트를 쉽게 추가할 수 있습니다.
4. **응용력**: 채팅뿐 아니라, 게임 로비, 실시간 협업, 위치 추적, 방송 등 폭넓게 활용 가능합니다.

> 정리하자면 “Socket.IO로 단순 채팅 기능을 넘어, 인증된 사용자에게만 안전하게 빠른 소켓 연결 기회를 주고, 이를 이벤트 기반으로 탄탄하게 다룰 수 있다”는 것이 핵심입니다. 게임 로비, 라이브 QnA, 배달 추적 등 다양한 분야에서 실시간성을 크게 높여줄 수 있습니다.
